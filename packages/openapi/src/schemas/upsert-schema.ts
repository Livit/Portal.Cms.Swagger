import { OpenAPIV3 } from 'openapi-types';
import { SanitizedConfig } from 'payload/config';
import traverse from 'traverse';
import { getSingularSchemaName } from '../utils';

const isRefCollection = (config: SanitizedConfig, ref: string): boolean => {
  const schemaName = /#\/components\/schemas\/(.*)/.exec(ref)?.[1];
  return config.collections.some(collection => getSingularSchemaName(collection) === schemaName);
};

export const createUpsertSchema = (config: SanitizedConfig, schema: OpenAPIV3.SchemaObject): OpenAPIV3.SchemaObject => {
  const removedProperties = ['id', 'lastModifiedBy', 'updatedAt', 'createdAt'];
  // Deep copy of the schema object
  schema.title = schema.title ?? 'Upsert' + schema.title;
  const jsonSchema = JSON.parse(JSON.stringify(schema));
  // eslint-disable-next-line func-names, prefer-arrow-callback
  traverse(jsonSchema).forEach(function (node) {
    // Replace reference schema object with string type.
    // This is required for upsert operations, as the Payload Cms
    // does not use nested object for relation field data.
    const isRefCollectionNode = this.key === '$ref' && isRefCollection(config, node);
    if (isRefCollectionNode && this.parent?.node) {
      const isSchemaObject = this.parent?.parent?.key === 'properties';
      const isSchemaArray = this.parent?.key === 'items' && this.parent?.parent?.node?.type === 'array';

      if (isSchemaObject || isSchemaArray) {
        this.parent.node = {
          type: 'string',
        };
        this.parent.update(this.parent.node);
        return;
      }
    }

    if (isRefCollectionNode && this.parent?.parent?.node && Array.isArray(this.parent?.parent?.node)) {
      this.parent.remove();
      const isPartOfSubSchemasGroup = ['oneOf', 'allOf', 'anyOf'].includes(this.parent.parent.key ?? '');

      if (!isPartOfSubSchemasGroup) {
        return;
      }

      const containsStringType = this.parent.parent.node.some(item => item.type === 'string');
      const replaceParentNode = this.parent.parent.node.length === 1 && containsStringType;
      if (replaceParentNode && this.parent.parent.parent?.node) {
        this.parent.parent.parent.node = {
          type: 'string',
        };
        this.parent.parent.parent.update(this.parent.parent.parent.node);
        return;
      }

      if (!containsStringType) {
        this.parent.parent.node = [...this.parent.parent.node, { type: 'string' }];
        this.parent.parent.update(this.parent.parent.node);
        return;
      }
    }

    // Remove unnecessary properties from required array.
    // These fields are automatically generated by the system and should not be required for upsert operations.
    // Path length is used to determine the depth of the node in the schema, i.e. rootSchema[0] -> properties[1] -> key[2] -> required[3]
    if (typeof node !== 'object' && this.path?.length < 4) {
      return;
    }

    if (this.path?.length === 1 && this.key === 'required') {
      node = node.filter((key: string) => !removedProperties.includes(key));
      if (node.length === 0) {
        this.remove();
        return;
      }

      this.update(node);
      return;
    }

    if (this.path?.length === 2 && this.key && removedProperties.includes(this.key)) {
      this.remove();
    }
  });

  return jsonSchema;
};
